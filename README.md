# ساختار برنامه در زبان C
برای نوشتن یه برنامه کوتاه، شاید نوشتن اون توی یک فایل، منطقی به نظر برسه. اما یکم که برناممون بزرگ بشه، نوشتن اون توی یه فایل می تونه خیلی شلوغ بکنه کار رو. پیدا کردن توابع مختلف و عیب یابی تو این حالت سخت میشه و خواننده رو حسابی گیج می کنه.

توی این آموزش می خوام شیوه تفکیک فایل ها در زبان C رو بهتون آموزش بدم. 


# حالت اول: همه برنامه در یک فایل
تو فایل زیر دوتا تابع تعریف کردم. برای فهم بهتر خیلی فایل `main.c` رو شلوغ نکردم. ولی در پروژه مبانی، خواهید دید که برنامه خیلی شلوغ میشه و باید یکم مرتب کنید ساختار برنامه تون رو.
### main.c
```c
#include <stdio.h>

void draw_circle(int radius);
int sum(int first_number, int second_number);

int main() {
    printf("Hello World!\n");
    int value = sum(2, 3);
    draw_circle(value);
    return 0;
}

void draw_circle(int radius) {
    printf("This function will draw a circle with radius %d.\n", radius);
}

int sum(int first_number, int second_number) {
    return first_number + second_number;
}
```

## کامپایل
برای کامپایل و بعدش اجرای برنامه، باید دستور زیر رو اجرا کنیم.
```sh
gcc main.c -o program.exe && ./program.exe
```
توی این دستور فایل `main.c` رو به کامپایلر `gcc` دادیم. 
بعدش با `o program.exe-` اسم فایل اجرایی خروجی رو تعیین کردیم. (این مورد اختیاریه و می تونید نذارید.)
آخرش هم با `&&` می گیم که اگر دستور قبلی موفیقت آمیز بود، برو دستور بعدی رو اجرا کن.
دستور بعدی هم فایل اجرایی ساخته شده توسط کامپایلر رو اجرا می کنه.
راستی اگه ترمینالتون توی ویندوز cmd بود، باید دستور زیر رو به جای دستور بالایی اجرا کنید. (زیاد فرق ندارن. فقط آخرش :) )
```
gcc main.c -o program.exe && program.exe
```

# حالت دوم: فایل های جدا
بیایید یه کاری بکنیم. هر چی تابع تعریف کردیم (به جز تابع main) رو ببریم توی فایل های  جدا تا فایل `main.c` یکم خلوت تر بشه.

توی C یه سری فایل هست به نام فایل های  `source` که با پسوند `c.` مشخص میشن. فایل های سورس محل کد هامون هست و کد های اصلی توی این فایل ها نوشته میشه.

یه سری فایل با پسوند `h.` هم داریم که اسمشون `header file` هست. فایل های هدر محل تعریف توابع، متغیر ها، ساختار ها، enum ها، ماکرو ها و... هستن. توی فایل هدر ما یک بار تعریف می کنیم و می تونیم این فایل رو در چند فایل سورس استفاده کنیم.



خب حالا یک فایل به نام `controller.h` می سازیم و `prototype` توابع رو داخلش قرار می دیم. دقت کنید که ما فقط `prototype` توابع رو اینجا قرار می دیم و تعریف عملکرد توابع باید تو فایل بعدی قرار بگیره. همچنین فراخوانی کتابخانه `stdio.h` رو هم در این فایل قرار می دیم. 
### controller.h
```c
#ifndef CONTROLLER_H
#define CONTROLLER_H

#include <stdio.h>

int sum(int first_number, int second_number);
void draw_circle(int radius);

#endif
```
توی دو خط اول این فایل و خط آخر یه سری دستورات پیش پردازنده وجود دارن که در این مثالی که زدیم، الزامی نبودن. اما وقتی تعداد فایل های هدر زیاد بشه ممکنه یه فایل هدر چندبار صدا زده بشه، که در این صورت، کامپایلر موجودات فایل هدر رو چند بار تعریف می کنه و این باعث خطا هنگام کامپایل میشه. برای حل مشکل **تعریف شدن چندباره**، از یه سری ماکرو استفاده می کنن که به کامپایلر بفهمونه تنها در صورتی این فایل هدر رو بخون که قبلا نخوندی. با این  تکنیک دیگه خطای قبلی برامون پیش نمیاد.


---


فایل بعدی ای که می سازیم، فایل `controller.c` هست که در اون توابع خودمون رو پیاده سازی می کنیم. اول این فایل، فایل هدر `controller.h` رو فراخوانی می کنیم. این فراخوانی مثل این می مونه که تمام محتویات فایل هدر رو اینجا کپی کرده باشیم.
### controller.c
```c
#include "controller.h"

int sum(int first_number, int second_number) {
    return first_number + second_number;
}

void draw_circle(int radius) {
    printf("This function will draw a circle with radius %d.\n", radius);
}
```
ممکنه براتون سوال بشه که چرا موقع فراخوانی از "" به جای <> استفاده کردیم. جواب این سوال اینه که وقتی `"file.h"` رو `include` می کنیم، کامپایلر ابتدا دایرکتوری ای که برنامه مون توی اون هست رو جست و جو می کنه تا `file.h` رو پیدا کنه و ضمیمه برناممون بکنه. اگه پیدا نکرد می ره توی دایرکتوری کتابخانه های استاندارد (`system include path`) دنبال این فایل می گرده. برعکس این حالت هم صادقه. یعنی اگه از <> در `include` اسفاده کنیم، اول `system include path` رو می گرده بعد میاد دایرکتوری پروژمون رو می گرده. خلاصه حرفام اینه که اگه از یه کتابخانه استاندارد خواستیم استفاده کنیم، از <> استفاده می کنیم. و اگه خواستیم از یه فایل هدری که خودمون ساختیم، استفاده کنیم از "" استفاده می کنیم، تا اگه فایل هدری هم نام با فایل هدر یک کتابخانه استاندارد داشته باشیم، فایل صحیح، `include` بشه.

---

در آخر با `include` کردن فایلی که ساختیم، فایل `main.c` ما این شکلی می شود. در اینجا نیاز نیست کتابخانه `stdio.h` را هم اضافه کنیم. چراکه قبلا در فایل `controller.h` اضافه کرده بودیم. با این کار هایی که کردیم، فایل `main.c` ما خیلی تمیز تر و خوانا تر شده.

### main.c
```c
#include "controller.h"

int main() {
    printf("Hello World!\n");
    int value = sum(2, 3);
    draw_circle(value);
    return 0;
}
```
## کامپایل
گفتیم که `include` کردن مثل کپی کردن فایل هدر در مقصد هست. خب این یعنی بین فایل `main.c` و فایل `controller.h` ارتباط هست. اما در کدی که زدیم هیچ ارتباطی بین `main.c` و فایل `controller.c` دیده نمیشه. برای ایجاد این ارتباط باید به کامپایلر دستور بدیم تا این فایل ها رو با هم کامپایل بکنه. (درست تر اینه که بگم linker فایل ها رو بهم متصل بکنه) این دستور مشابه دستور قبلیه منتها باید همه `source` فایل ها رو در دستور کامپایل قرار بدیم.
```sh
gcc main.c controller.c -o program.exe && ./program.exe
```
بازم تکرار این نکته بد نیست که اگه ترمینالتون cmd باشه، دستور اجرای فایل exe بدون `/.` خواهد بود.

# جمع بندی
توی این آموزش سعی کردم در کنار توضیح شیوه جدا کردن فایل ها در زبان C کوچیک ترین نکات  رو هم توضیح بدم تا اگه سوالی براتون پیش اومد، سریع بتونید جواب اون رو پیدا کنید. تو آموزش بعدی درباره شیوه اضافه کردن کتابخانه های دیگران به پروژه خودمان توضیح می دم. و شما رو با CMake که یک ابزار قدرتمند برای build کردن پروژه ها هست، آشنا می کنم.
امیدوارم این فایل به دردتون بخوره. اگه بازم سوالی داشتین حتما تو تلگرام ازم بپرسین. موفق باشید. 

**سید علی طیب / شهریور 1401**
